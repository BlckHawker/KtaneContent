<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>Game of Ants â€” Keep Talking and Nobody Explodes Module</title>
    <link rel="stylesheet" type="text/css" href="css/font.css">
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <script src="js/ktane-utils.js"></script>
    <script src="js/jquery.3.7.0.min.js"></script>
    <script src="js/Utilities/svg-utils.js"></script>
    <script src="js/Utilities/math-utils.js"></script>
    <script src="js/Utilities/ui-utils.js"></script>
    <script>
    $(function() {
        let selected;
        let selectedTool;
        let rotating = false;
        let golgrid = $(".grid.gol-grid");
        let grid = $(".grid.ant-grid");
        let generating = false;
        let saveStates = [];
        let currentState = 0;
        let readState;
        const rows = 5;
        const cols = 5;
        const nAnts = 5;
        const animDelay = 1800;
        let currX = 0;
        let currY = 0;
        let gameGrid = Array(rows).fill().map(()=>Array(cols).fill(false));
        let origGameGrid = Array(rows).fill().map(()=>Array(cols).fill(false));
        let animTimeout = null;
        const MODE_READ = 0;
        const MODE_SOLVE = 1;
        const MODE_PLAY = 2;
        const MODE_GOL = 3;
        const MODE_ANT = 4;

        let squareColors = ["white", "black"];
        const directions = {
            Up: [0, -1],
            Left: [-1, 0],
            Down: [0, 1],
            Right: [1, 0],
            w: [0, -1],
            a: [-1, 0],
            s: [0, 1],
            d: [1, 0],
            0: [0, -1],
            1: [-1, 0],
            2: [0, 1],
            3: [1, 0]
        }
        const dirIndex = {
            Up: 0,
            Right: 1,
            Down: 2,
            Left: 3,
            w: 0,
            d: 1,
            s: 2,
            a: 3,
        };

        function selectNone() {
            selectedTool = null;
            rotating = false;
            updateSelection();
        }

        function updateSelection() {
            $(".selected").removeClass("selected");
            if (selected && selected.length > 0) {
                selected.addClass("selected");
            }
        }

        function saveReadState() {
            readState = Array.from($(".netsquare, .ant-child")).map(x => $(x)).map(x => x.attr("class") || "");
        }

        function resetPos() {
            if (readState) {
                $(".netsquare, .ant-child").each((i, x) => $(x).attr("class", readState[i]));
            }
            selected = $(".antsquare.x0.y0");
            selectNone();
            currX = currY = 0;
            gameGrid = JSON.parse(JSON.stringify(origGameGrid));
            $(".leave-button").removeClass("leave");
        }

        function coordinateName(coord) {
            return `${String.fromCharCode(65 + coord[1])}${coord[0] + 1}`;
        }

        function hasWhichColor(elem) {
            for (var i = 0; i < squareColors.length; i++) {
                if (elem.hasClass(squareColors[i])) return i;
            }
            return -1;
        }

        function nextColor(elem) {
            let c = hasWhichColor(elem);
            removeColorClass(elem);
            elem.addClass(squareColors[(c + 1) % squareColors.length]);
        }

        function removeColorClass(elem) {
            elem.removeClass("white black");
        }

        function hasWhichAnt(elem) {
            for (var i = 1; i <= nAnts; i++) {
                if (elem.hasClass(`ant${i}`)) return i;
            }
            return -1;
        }

        function removeOthers(which, manual = true) {
            let antClass = `ant${which}`;
            $(`.netsq.ant.${antClass}`).removeClass(`ant ${antClass} arot0 arot1 arot2 arot3`);
            let antChild = $(`.ant-child.${antClass}`).first();
            if (antChild.length > 0) {
                let parent = antChild.parent();
                antChild.removeClass(`ant ${antClass} arot0 arot1 arot2 arot3`);
                antChild = parent.find(".ant-child.ant");
                if (antChild.length == 1) {  //only one ant remains, convert back to single ant cell
                    let a = hasWhichAnt(antChild);
                    let r = hasWhichRot(antChild);
                    parent.removeClass("multiple ant");
                    if (manual) {
                        setTimeout(function() {
                            antChild.removeClass(`ant ant${a} arot${r}`);
                            if ($(`.netsq.ant.ant${a}`).length == 0 && $(`.ant-child.ant.ant${a}`).length == 0)
                                parent.addClass(`ant ant${a} arot${r}`);
                        }, 100);
                    }
                    else {
                        antChild.removeClass(`ant ant${a} arot${r}`);
                        parent.addClass(`ant ant${a} arot${r}`);
                    }
                }
            }
        }

        function setAnt(elem, which = 1, rot = 0, manual = true) {
            let antClass = `ant${which}`;
            let rotClass = `arot${rot}`;
            if (elem.hasClass("ant")) {
                if (elem.hasClass("multiple")) {    //already multiple ants here
                    let antChild = elem.find(`.ant-child.${antClass}`).first();
                    if (antChild.length > 0) {  //ant-child already has this type
                        if (antChild.hasClass(rotClass)) {  //and rotation, remove entirely
                            if (manual) removeOthers(which);
                        } else {                            //give new rotation
                            antChild.removeClass(`arot0 arot1 arot2 arot3`).addClass(rotClass);
                        }
                    }
                    else {  //no ant-child has this type yet
                        removeOthers(which, manual);
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        if (antChild.length > 0) {  //there is an available slot
                            antChild.addClass(`ant ${antClass} ${rotClass}`);
                        }
                    }
                }
                else {  //exactly one ant here so far
                    if (elem.hasClass(antClass)) {  //the one ant is already this type
                        if (elem.hasClass(rotClass)) {  //and matching rotation, remove entirely
                            if (manual) removeAnts(elem);
                        } else {                        //but not rotation, give new rotation
                            elem.removeClass(`arot0 arot1 arot2 arot3`).addClass(rotClass);
                        }
                    }
                    else {  //turn into a shared cell and add new ant
                        removeOthers(which, manual);
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        elem.addClass("multiple");
                        let a = hasWhichAnt(elem);
                        let r = hasWhichRot(elem);
                        elem.removeClass(`ant${a} arot${r}`);
                        antChild.addClass(`ant ant${a} arot${r}`);          //place parent ant in first cell
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        antChild.addClass(`ant ${antClass} ${rotClass}`);   //place new ant in second cell
                    }
                }
            }
            else {
                removeOthers(which, manual);
                removeAnts(elem);
                elem.addClass(`ant ant${which} arot${rot}`);
            }
        }

        function removeAnts(elem) {
            const classes = "ant multiple arot0 arot1 arot2 arot3 ant1 ant2 ant3 ant4 ant5";
            elem.removeClass(classes);
            elem.find(".ant-child").removeClass(classes);
        }

        function nextRotation(elem, cc = false) {
            let c = hasWhichRot(elem);
            let rot = UMod(c + (cc ? -1 : 1), 4);
            elem.removeClass("arot0 arot1 arot2 arot3").addClass(`arot${rot}`);
            return rot;
        }

        function hasWhichRot(elem) {
            for (var i = 0; i < 4; i++)
                if (elem.hasClass(`arot${i}`)) return i;
            return -1;
        }

        const antdir = [
            [], [2], [2], [2], [],
            [1], [1, 2], [1, 2, 3], [2, 3], [3],
            [1], [0, 1, 2], [0, 1, 2, 3], [0, 2, 3], [3],
            [1], [0, 1], [0, 1, 3], [0, 3], [3],
            [], [0], [0], [0], []
        ];
        const dirs = "URDL";

        let antSteps = [];
        let gridStates = [];
        let animStep = 0;

        function isSolved() {
            if (mode() !== MODE_PLAY) return false;

            // Check ant positions and orientations
            let antPositions = {};
            for (let [y, x, r] of antSteps[antSteps.length - 1]) {
                let elem = $(`.netsq.x${x}.y${y}`);
                if (elem.length > 0) {
                    if (!elem.hasClass("ant")) {
                        console.log(coordinateName([y,x]), "ant mismatch");
                        return false;
                    }
                    if (!elem.hasClass(`arot${r}`)) {
                        console.log(coordinateName([y,x]), `arot${r} mismatch`);
                        return false;
                    }
                }
                // else console.log(coordinateName([y,x]), "does not exist");
            }
            console.log("ants match");

            let correctButtons = [];
            // Check leave buttons
            for (let ant of antSteps[antSteps.length - 1]) {
                if (ant[0] < 0 || ant[0] >= rows || ant[1] < 0 || ant[1] >= cols) {
                    let leaveButtonQ = ant[0] < 0 ? `.btn-w.l${ant[1]}` :
                        ant[0] >= rows ? `.btn-s.l${ant[1]}` :
                        ant[1] < 0 ? `.btn-a.l${ant[0]}` : `.btn-d.l${ant[0]}`;
                    let leaveButton = $(leaveButtonQ);
                    correctButtons.push(leaveButton.attr("class"));
                    if (leaveButton.length < 1 || !leaveButton.hasClass("leave")) {
                        console.log(`${leaveButtonQ} mismatch`);
                        return false;
                    }
                }
            }
            let selectedButtons = $(".leave-button.leave");
            if (correctButtons.length != selectedButtons.length) {
                console.log("extra exits");
                return false;
            }
            console.log("exits match");

            // Check grid colors
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let elem = $(`.netsq.x${x}.y${y}`);
                    let expected = gridStates[gridStates.length - 1][y][x];
                    if (elem.hasClass("white") !== expected) {
                        console.log(coordinateName([y,x]), "grid mismatch");
                        return false;
                    }
                }
            }
            console.log("grid matches");
            if ($("button.sound").hasClass("play")) {
                audioSolve[0].play();
            }

            return true;
        }

        function animate() {
            // Reset the grid to the initial state
            resetPos();

            // Start the animation
            animStep = 0;
            animTimeout = setTimeout(animateStep, animDelay);
        }

        function animateStep() {
            if (animStep <= antSteps.length) {
                // Display each step of ant movement
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let elem = $(`.netsq.x${x}.y${y}`);
                        removeColorClass(elem);
                        elem.addClass(squareColors[gridStates[animStep][y][x] ? 0 : 1]);
                    }
                }
                if (animStep > 0) {
                    antSteps[animStep - 1].forEach((ant, i) => {
                        if (ant[0] < 0 || ant[0] >= rows || ant[1] < 0 || ant[1] >= cols) {
                            // console.log("ant", ant);
                            if (ant[0] < 0) {
                                $(`.btn-w.l${ant[1]}`).addClass("leave");
                            }
                            if (ant[0] >= rows) {
                                $(`.btn-s.l${ant[1]}`).addClass("leave");
                            }
                            if (ant[1] < 0) {
                                $(`.btn-a.l${ant[0]}`).addClass("leave");
                            }
                            else {
                                $(`.btn-d.l${ant[0]}`).addClass("leave");
                            }
                            removeOthers(i + 1);
                        }
                        else {
                            setAnt($(`.antsquare.x${ant[1]}.y${ant[0]}`), i + 1, ant[2], false);
                        }
                    });
                }
            } else {
                // Display the final grid state
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let elem = $(`.netsq.x${x}.y${y}`);
                        removeColorClass(elem);
                        elem.addClass(squareColors[gridStates[animStep][y][x] ? 0 : 1]);
                    }
                }
                $(".pause-button").addClass("pause");
                return;
            }

            animStep++;
            animTimeout = setTimeout(animateStep, animDelay);
        }

        function generate() {
            if (generating) return;
            generating = true;

            // Clear previous data
            antSteps = [];
            gridStates = [];

            // Initialize the grid randomly
            for (let i = 0; i < 25; i++) {
                let r = Random(0, 2) > 0;
                let y = Math.floor(i / 5);
                let x = i % 5;
                gameGrid[y][x] = r;
                origGameGrid[y][x] = r;
                $(`.netsq.x${x}.y${y}`).removeClass("black white").addClass(r ? "white" : "black");
            }

            // console.log(`The initial state of the grid is:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "â–¡" : "â– ").join("")).join("\n"));

            // Perform one iteration of Game of Life
            gameGrid = G(gameGrid);
            gridStates.push(gameGrid.map(row => row.slice()));

            // console.log(`The life phase yields:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "â–¡" : "â– ").join("")).join("\n"));

            // Display life phase
            let svgsz = 112, xoff = 2, yoff = 2, dx = 22, dy = 22, sw = 20, sh = 20;
            let lifePhase = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    lifePhase.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .life-phase").html("").append(lifePhase);

            // Initialize ants randomly
            let antnum = Random(2, 6);
            let antinit = [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23];
            let antpos = [];
            for (let i = 0; i < antnum; i++) {
                let r = PickRandom(antinit);
                antinit = antinit.filter(x => x !== r);
                let y = Math.floor(r / 5);
                let x = r % 5;
                let d = PickRandom(antdir[r]);
                antpos.push([y, x, d]);
            }

            let antcoord = new Array(antnum);
            let antshare = new Array(antnum);
            let antlog = new Array(antnum);
            antpos.sort((a,b) => a[1] == b[1] ? (a[0] - b[0]) : (a[1] - b[1]));
            removeAnts($(".antsquare"));
            for (let i = 0; i < antnum; i++) {
                let ant = antpos[i];
                antlog[i] = coordinateName(ant) + ":";
                setAnt($(`.antsquare.x${ant[1]}.y${ant[0]}`), i + 1, ant[2]);
            }

            while (true) {
                let antStep = [];
                for (let i = 0; i < antnum; i++) {
                    Move(antpos[i], true);
                    antcoord[i] = antpos[i][0] * 6 + antpos[i][1];
                    antlog[i] += dirs[antpos[i][2]];
                    antStep.push([...antpos[i]]);
                }
                antSteps.push(antStep);
                gridStates.push(gameGrid.map(row => row.slice()));

                for (let i = 0; i < antnum; i++) {
                    antshare[i] = antcoord.filter((x, k) => k != i && x == antcoord[i]).length > 0 && antpos.map(x => x[2]).filter((x, k) => k > i && antcoord[k] == antcoord[i]).every(x => x != antpos[i][2]);
                }

                while (antshare.some(x => x)) {
                    antStep = [];
                    for (let i = 0; i < antnum; i++) {
                        if (antshare[i]) {
                            Move(antpos[i], false);
                            antcoord[i] = antpos[i][0] * 6 + antpos[i][1];
                            antlog[i] += dirs[antpos[i][2]];
                        }
                        else {
                            antlog[i] += "-";
                        }
                        antStep.push([...antpos[i]]);
                    }
                    antSteps.push(antStep);
                    gridStates.push(gameGrid.map(row => row.slice()));

                    for (let i = 0; i < antnum; i++) {
                        antshare[i] = antcoord.filter((x, k) => k != i && x == antcoord[i]).length > 0 && antpos.map(x => x[2]).filter((x, k) => k > i && antcoord[k] == antcoord[i]).every(x => x != antpos[i][2]);
                    }
                }

                if (antpos.some(x => x[0] < 0 || x[0] >= rows || x[1] < 0 || x[1] >= cols)) {
                    break;
                }

                //rotate
                for (let i = 0; i < antnum; i++) {
                    let ant = antpos[i];
                    if (ant[0] >= 0 && ant[0] < rows && ant[1] >= 0 && ant[1] < cols) {
                        ant[2] = (ant[2] + (gameGrid[ant[0]][ant[1]] ? 1 : 3)) % 4;
                    }
                }
            }

            for (let i = 0; i < antnum; i++) {
                let ant = antpos[i];
                antlog[i] += ":";
                if (ant[0] < 0) {
                    antpos[i][0] = -1;
                    antpos[i][2] = 0;
                    antlog[i] += "OUT N" + (ant[1] + 1);
                } else if (ant[0] > 4) {
                    antpos[i][0] = rows;
                    antpos[i][2] = 2;
                    antlog[i] += "OUT S" + (ant[1] + 1);
                } else if (ant[1] < 0) {
                    antpos[i][1] = -1;
                    antpos[i][2] = 3;
                    antlog[i] += "OUT W" + (ant[0] + 1);
                } else if (ant[1] > 4) {
                    antpos[i][1] = cols;
                    antpos[i][2] = 1;
                    antlog[i] += "OUT E" + (ant[0] + 1);
                } else {
                    antlog[i] += coordinateName(ant);
                }
            }

            // console.log(`The ants travel along the following paths:`);
            // console.log(antlog.join("\n"));

            // Display ant travel
            $(".solution .ant-travel").html(antlog.join("<br>"));

            // console.log(`The ant phase yields:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "â–¡" : "â– ").join("")).join("\n"));

            // Display ant phase
            let antPhase = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    antPhase.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .ant-phase").html("").append(antPhase);

            // Perform another iteration of Game of Life
            gameGrid = G(gameGrid);

            // console.log(`The final state of the grid is:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "â–¡" : "â– ").join("")).join("\n"));

            // Display final state
            let finalState = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    finalState.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .final-state").html("").append(finalState);
            gridStates.push(gameGrid.map(row => row.slice()));

            generating = false;
        }

        function G(s) {
            let z = Array(5).fill().map(() => Array(5).fill(false));
            for (let i = 0; i < 25; i++) {
                let p = 0;
                for (let j = 0; j < 3; j++) {
                    let x = Math.floor(i / 5) + (j - 1);
                    if (x < 0 || x > 4) continue;
                    for (let k = 0; k < 3; k++) {
                        let y = (i % 5) + (k - 1);
                        if (y < 0 || y > 5) continue;
                        if (s[x][y]) p++;
                    }
                }
                if (p === 3 || (p === 4 && s[Math.floor(i / 5)][i % 5])) {
                    z[Math.floor(i / 5)][i % 5] = true;
                }
            }
            return z;
        }

        function Move(ant, toggle) {
            if (toggle) {
                gameGrid[ant[0]][ant[1]] = !gameGrid[ant[0]][ant[1]];
            }
            switch (ant[2]) {
                case 0: ant[0]--; break;
                case 1: ant[1]++; break;
                case 2: ant[0]++; break;
                default: ant[1]--; break;
            }
        }

        function Random(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        function PickRandom(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function coordinate(pos) {
            return [ pos % cols, Math.floor(pos / cols) ];
        }

        let autoclick = false;
        function arrowPressed(direction, dirIdx) {
            if (selected && mode() != MODE_READ && selected.hasClass("ant")) {
                let ant = selected.hasClass("multiple") ? selected.find(".ant-child.ant").first() : selected;
                let antType = hasWhichAnt(ant);
                let x = currX + direction[0];
                let y = currY + direction[1];
                if (x < 0 || x >= cols || y < 0 || y >= rows) {
                    removeOthers(antType);
                    let leaveButton = direction[0] == -1 ? $(`.btn-a.l${currY}`) :
                        direction[0] == 1 ? $(`.btn-d.l${currY}`) :
                        direction[1] == -1 ? $(`.btn-w.l${currX}`) : $(`.btn-s.l${currX}`);
                    leaveButton.addClass("leave");
                } else {
                    let elem = $(`.antsquare.x${x}.y${y}`);
                    setAnt(elem, antType, dirIdx);
                    autoclick = true;
                    elem.click();
                }
                if (isSolved()) $(".solved-text").removeClass("invis");
                else $(".solved-text").addClass("invis");
            }
        }

        let down = false;
        $(document).click(function() {
            selectNone();
        }).keydown(function(event) {
            if (down)
                return false;
            down = true;
            let k = event.key.toLowerCase();
            if (event.key.startsWith("Arrow")) {
                let d = event.key.substring(5);
                arrowPressed(directions[d], dirIndex[d]);
                event.preventDefault();
            } else if (NoSpecialKeys(event) && (k == "w" || k == "a" || k == "s" || k == "d")) {
                arrowPressed(directions[k], dirIndex[k]);
                event.preventDefault();
            } else if (NoSpecialKeys(event)) {
                let n = parseInt(event.key);
                if (k == " " || k == "enter" || (n >= 0 && n <= 1)) {
                    if (k == " " || k == "enter" || n == 0) {
                        playZeroOneSound(false);
                        removeColorClass(selected);
                        selected.addClass("black");
                        gameGrid[currY][currX] = false;
                    }
                    else {
                        playZeroOneSound(true);
                        removeColorClass(selected);
                        selected.addClass("white");
                        gameGrid[currY][currX] = true;
                    }
                    if (mode() == MODE_READ) {
                        if (currX == cols - 1)
                            currY = (currY + 1) % cols;
                        currX = (currX + 1) % rows;
                        selected = $(`.golsquare.x${currX}.y${currY}`);
                        updateSelection();
                    }
                }
            }
            down = false;
            if (k == " " || k == "enter") return false;
        });

        $(".arrows button").click(function(event) {
            let q = this.className.split("-")[1];
            arrowPressed(directions[q], dirIndex[q]);
            event.preventDefault();
            event.stopPropagation();
        });

        function mode() {
            if ($("button.expert-play").hasClass("play"))
                return MODE_PLAY;
            else if ($("button.read-solve").hasClass("solve"))
                return MODE_SOLVE;
            else
                return MODE_READ;
        }

        let row = $("<div>").addClass("square-row letters").appendTo(golgrid);
        $("<div>").addClass("square").appendTo(row);
        for (var i = 0; i < cols; i++) {
            $("<div>").addClass("square").text(String.fromCharCode(65 + i)).appendTo(row);
        }
        for (let y = 1; y <= rows; y++) {
            row = $("<div>").addClass("square-row").appendTo(golgrid);
            $("<div>").addClass("square numbers").text(y).appendTo(row);
            for (let x = 1; x <= cols; x++) {
                let square = $("<div>").addClass(`netsquare square netsq golsquare x${x-1} y${y-1} black`).appendTo(row).each(function(_, e) {
                    var element = $(e);
                    element.click(function() {
                        let group = $(`.netsquare.x${x-1}.y${y-1}`);
                        nextColor(group);
                        selected = $(`.golsquare.x${x-1}.y${y-1}`);
                        let n = selected.hasClass("white");
                        updateSelection();
                        currX = x-1;
                        currY = y-1;
                        origGameGrid[y-1][x-1] = gameGrid[y-1][x-1] = n;
                        if (isSolved()) $(".solved-text").removeClass("invis");
                        else {
                            $(".solved-text").addClass("invis");
                            playZeroOneSound(n);
                        }
                    }).contextmenu(function() {
                        $(this).toggleClass("dot");
                        playDZeroOneSound($(this).hasClass("dot"));
                        return false;
                    });
                });
            }
        }
        row = $("<div>").addClass("square-row letters").appendTo(grid);
        $("<div>").addClass("square").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        for (var x = 0; x < cols; x++) {
            $("<div>").addClass("square").text(String.fromCharCode(65 + x)).appendTo(row);
        }
        row = $("<div>").addClass("hstack arrow-row").appendTo(grid);
        $("<div>").addClass("square-spacer").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        //add leave buttons
        for (var x = 0; x < cols; x++) {
            let holder = $("<div>").addClass("square-spacer vstack alignc").appendTo(row);
            $("<button>").addClass(`leave-button btn-w l${x}`).text("â–¼").appendTo(holder);
        }
        for (let y = 1; y <= rows; y++) {
            row = $("<div>").addClass("square-row").appendTo(grid);
            $("<div>").addClass("square numbers").text(y).appendTo(row);
            //add leave buttons
            $("<button>").addClass(`leave-button btn-a l${y-1}`).text("â–¼").appendTo(row);
            for (let x = 1; x <= cols; x++) {
                let square = $("<div>").addClass(`netsquare square antsquare netsq x${x-1} y${y-1} black`).appendTo(row).each(function(_, e) {
                    var element = $(e);
                    element.click(function(event) {
                        if (rotating || event.ctrlKey || event.metaKey || event.shiftKey) {
                            let antElems = element.hasClass("multiple") ? element.find(".ant-child.ant") : element;
                            antElems.each(function() {
                                nextRotation($(this), event.shiftKey);
                            });
                            return false;
                        }
                        if (selectedTool && selectedTool.startsWith("ant")) {
                            for (let a = 1; a <= nAnts; a++) {
                                if (selectedTool.startsWith(`ant ant${a}`)) {
                                    let r = parseInt(selectedTool.split("arot")[1]);
                                    setAnt(element, a, r);
                                    break;
                                }
                            }
                            return false;
                        }
                        let group = $(`.antsquare.x${x-1}.y${y-1}`);
                        selected = group;
                        updateSelection();
                        currX = x-1;
                        currY = y-1;

                        if (!autoclick) {
                            nextColor($(`.netsq.x${x-1}.y${y-1}`));
                            let n = group.hasClass("white");
                            if (isSolved()) $(".solved-text").removeClass("invis");
                            else {
                                $(".solved-text").addClass("invis");
                                playZeroOneSound(n);
                            }
                            gameGrid[y-1][x-1] = n;
                        }
                        autoclick = false;
                    });
                    element.contextmenu(function() {
                        let group = $(`.antsquare.x${x-1}.y${y-1}`);
                        selected = group;
                        updateSelection();
                        currX = x-1;
                        currY = y-1;
                        return false;
                    });
                    
                    //add child squares
                    for (let i = 0; i < 4; i++) {
                        $("<div>").addClass(`ant-child ant-child-${i}`).appendTo(element);
                    }
                });
            }
            //add leave buttons
            $("<button>").addClass(`leave-button btn-d l${y-1}`).text("â–¼").appendTo(row);
        }
        row = $("<div>").addClass("hstack arrow-row").appendTo(grid);
        $("<div>").addClass("square-spacer").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        //add leave buttons
        for (var x = 0; x < cols; x++) {
            let holder = $("<div>").addClass("square-spacer vstack alignc").appendTo(row);
            $("<button>").addClass(`leave-button btn-s l${x}`).text("â–¼").appendTo(holder);
        }

        $(".leave-button").click(function() {
            $(this).toggleClass("leave");
            if (isSolved()) $(".solved-text").removeClass("invis");
            else $(".solved-text").addClass("invis");
        });

        resetPos();
        selected = $(".golsquare.x0.y0");
        updateSelection();

        function playZeroOneSound(on) {
            if ($("button.sound").hasClass("play")) {
                let aud = on ? audio1[0].cloneNode() : audio0[0].cloneNode();
                aud.volume = 0.8;
                aud.play();
            }
        }
        function playDZeroOneSound(on) {
            if ($("button.sound").hasClass("play")) {
                let aud = on ? audiod1[0].cloneNode() : audiod0[0].cloneNode();
                aud.volume = 0.8;
                aud.play();
            }
        }

        let audio0 = $("<audio>")
            .attr("src", "audio/Not The Bulb/TapCode.wav")
            .appendTo(grid);
        let audio1 = $("<audio>")
            .attr("src", "audio/Not The Bulb/NonoClick.wav")
            .appendTo(grid);
        let audio2 = $("<audio>")
            .attr("src", "audio/Not The Bulb/SelectBulb.wav")
            .appendTo(grid);
        let audiod0 = $("<audio>")
            .attr("src", "audio/Old Fogey/BigButtonRelease.wav")
            .appendTo(grid);
        let audiod1 = $("<audio>")
            .attr("src", "audio/Old Fogey/BigButtonPress.wav")
            .appendTo(grid);
        let audioSolve = $("<audio>")
            .attr("src", "audio/Module Listening/Encrypted Equations - Solve.wav")
            .appendTo(grid);

        let tools = $(".tools");

        $("<div>").addClass("tool rotatetool").text("Rotate").appendTo(tools).click(function() {
            $(".tool").removeClass("selected");
            $(this).addClass("selected");
            rotating = true;
            event.preventDefault();
            event.stopPropagation();
        });
        
        $("<button>").addClass("read-solve").appendTo(tools).click(function() {
            $(this).toggleClass("solve");
            $("body").toggleClass("solve", $(this).hasClass("solve"));

            if (mode() == MODE_SOLVE) {
                saveReadState();
            }
            if (mode() != MODE_READ) {
                resetPos();
            }
        });
        $("<button>").addClass("sound play").appendTo(tools).click(function() {
            $(this).toggleClass("play");
        });
        $("<button>").addClass("expert-play").appendTo(tools).click(function() {
            if (generating)
                return false;
            $(this).toggleClass("play");
            $("body").toggleClass("play", $(this).hasClass("play"));
            if (mode() == MODE_PLAY) {
                $("body").removeClass("solution-shown");
                $("button.show-sol").removeClass("show");
                $("button.pause-button").removeClass("pause");
                generate();
                saveReadState();
            }
            clearTimeout(animTimeout);
            resetPos();
        });
        $("<button>").addClass("show-sol").appendTo(tools).click(function() {
            $(this).toggleClass("show");
            let show = $(this).hasClass("show");
            $("body").toggleClass("solution-shown", show);
            clearTimeout(animTimeout);
            if (show && mode() == MODE_PLAY) {
                $(".solved-text").addClass("invis");
                $("button.pause-button").removeClass("pause");
                animate();
            }
            else {
                resetPos();
            }
        });
        $("<button>").addClass("pause-button").appendTo(tools).click(function() {
            $(this).toggleClass("pause");
            if ($(this).hasClass("pause")) {
                clearTimeout(animTimeout);
            }
            else {
                animTimeout = setTimeout(animateStep, animDelay);
            }
        });

        let othertools = $("<div>").addClass("othertools square-row letters").appendTo(grid);
        $("<div>").addClass("square").appendTo(othertools);
        $("<div>").addClass("arrow-spacer").appendTo(othertools);
        for (let i = 0; i < nAnts; i++) {
            $("<div>").addClass(`tool ant arot0 ant${i+1}`).appendTo(othertools).click(function(event) {
                let elem = $(this);
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    let rot = nextRotation(elem, event.shiftKey);
                    if (elem.hasClass("selected"))
                        selectedTool = `ant ant${i+1} arot${rot}`;
                    return false;
                }
                if (rotating) {
                    nextRotation(elem, event.shiftKey);
                    return false;
                }
                $(".tool").removeClass("selected");
                elem.addClass("selected");
                let r = hasWhichRot(elem);
                selectedTool = `ant ant${i+1} arot${r}`;
                event.preventDefault();
                event.stopPropagation();
            });
        }
        $("<div>").css("width", "5px").appendTo(othertools);
        $("div.tool.reset-grid").click(function(event) {
            resetPos();
            event.preventDefault();
            event.stopPropagation();
        });

        $("button.clear-dots").click(function() {
            $(".gol-grid .dot").removeClass("dot");
        })

        $(".reset-saves").click(function() {
            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
        });
        $(".reset-all").click(function() {
            resetPos();
            $(".solved-text").addClass("invis");
            $("body").removeClass("solution-shown solve play");
            $("button.sound").addClass("play");
            $("button.expert-play").removeClass("play");
            $("button.show-sol").removeClass("show");
            $("button.read-solve").removeClass("solve");
            $(".leave-button").removeClass("leave");
            $(".netsq").removeClass(squareColors.join(" ")).addClass("black");
            removeAnts($(".antsquare"));
            $(".tool.ant").removeClass("arot1 arot2 arot3").addClass("arot0");
            let gameGrid = Array(cols).fill().map(()=>Array(rows).fill(false));
            let origGameGrid = Array(cols).fill().map(()=>Array(rows).fill(false));
            selected = $(".golsquare.x0.y0");
            updateSelection();

            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
        });

        function removeFutureSaves() {
            if (currentState < saveStates.length - 1) {
                for (let i = currentState + 1; i < saveStates.length; i++) {
                    saveStates[i].remove();
                }
                saveStates.splice(currentState + 1, saveStates.length - currentState);
            }
        }

        $("button.save").click(function() {
            removeFutureSaves();

            let saveStateClass = Array.from($(".netsquare, .ant-child, .tools button, .tool.ant, .leave-button")).map(x => $(x)).map(x => x.attr("class") || "");
            let saveSol = Array.from($(".solution div div")).map(x => $(x)).map(x => x.html() || "");
            let saveStateBody = Array.from($("body")).map(x => $(x)).map(x => x.attr("class") || "");
            console.log(saveStates);
            let stateNumber = saveStates.length;
            currentState = stateNumber;

            let s_readState = JSON.stringify(readState);
            let s_gameGrid = JSON.stringify(gameGrid);
            let s_origGameGrid = JSON.stringify(origGameGrid);
            let s_selected = selected;
            let s_selectedTool = selectedTool;
            let s_currX = currX;
            let s_currY = currY;
            let s_antSteps = JSON.stringify(antSteps); // Save antSteps
            let s_gridStates = JSON.stringify(gridStates); // Save gridStates

            let button = $("<button>").text(stateNumber + 1).click(function() {
                $(".netsquare, .ant-child, .tools button, .tool.ant, .leave-button").each((i, x) => $(x).attr("class", saveStateClass[i]));
                $(".solution div div").each((i, x) => $(x).html(saveSol[i]));
                $("body").each((i, x) => $(x).attr("class", saveStateBody[i]));
                currentState = stateNumber;
                selected = s_selected;
                selectedTool = s_selectedTool;
                currX = s_currX;
                currY = s_currY;
                gameGrid = JSON.parse(s_gameGrid);
                origGameGrid = JSON.parse(s_origGameGrid);
                readState = JSON.parse(s_readState);
                antSteps = JSON.parse(s_antSteps); // Restore antSteps
                gridStates = JSON.parse(s_gridStates); // Restore gridStates
            }).addClass("flash").appendTo(".saves");
            setTimeout(() => {
                button.removeClass("flash");
            }, 100);

            saveStates.push(button);
        });
    });
    </script>
    <style>
        :root {
            --sqsize: 77px;
        }
        .square-row {
            height: var(--sqsize);
            margin: 1px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }

        .square {
            margin: 1px;
            width: var(--sqsize);
            height: var(--sqsize);
            float: left;
            font-size: 30px;
            user-select: none;
            text-align: center;
            border: #808080 1px solid;
            transition: background-color 0.2s, color 0.2s;
            box-sizing: border-box;
        }
        .square.numbers, .letters .square {
            margin-top: 16px;
            border-width: 0;
            width: var(--sqsize);
            height: var(--sqsize);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .netsquare {
            height: var(--sqsize);
            width: var(--sqsize);
            font-size: 50px;
            line-height: 85px;
            font-weight: bold;
            cursor: pointer;
            background-color: #13140E;
            position: relative;
        }
        .netsquare.black {
            background-color: #000;
        }
        .netsquare.white {
            background-color: #FFF;
        }
        .netsquare::after {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            content: '';
            width: 0;
            height: 0;
            background: white;
            transition: background 0.2s, top 0.2s, left 0.2s, width 0.2s, height 0.2s;
        }
        .netsquare.dot::after {
            top: 50%;
            left: 50%;
            width: 20%;
            height: 20%;
        }

        .netsquare.white.dot::after {
            background: black;
        }

        .netsquare .ant-child.selected,
        .netsquare.selected {
            border: 4px dashed #00F;
        }

        .othertools .tool {
            margin: 1px;
        }
        .othertools {
            margin-top: 5px;
        }
        .tool {
            width: var(--sqsize);
            height: var(--sqsize);
            float: left;
            font-size: 40px;
            user-select: none;
            text-align: center;
            border: black 1px solid;
            padding-top: 7px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            box-sizing: border-box;
        }
        .tool, .netsquare {
            background-position: center;
            background-repeat: no-repeat;
            background-size: contain;
        }
        .tool.ant.selected { border: #E23 2px dashed; }
        .tool.rotatetool.selected { border: #33F 2px dashed; }
        .dark .tool:not(.selected) { border-color: #DDD; }

        .rotatetool {
            font-size: 15px;
            padding-top: 2px;
            border-radius: 50%;
        }

        .tools { width: 105px; }
        p.gridlabel { width: 105px; }
        .tools > button, .tools .tool {
            margin: 5px;
        }
        .solved-text {
            color: #0C0;
            transition: color 0.5s;
            user-select: none;
        }
        .invis { color: transparent; }

        .ant.ant1 { background-image: url("img/Game of Ants/ant1.svg"); }
        .ant.ant2 { background-image: url("img/Game of Ants/ant2.svg"); }
        .ant.ant3 { background-image: url("img/Game of Ants/ant3.svg"); }
        .ant.ant4 { background-image: url("img/Game of Ants/ant4.svg"); }
        .ant.ant5 { background-image: url("img/Game of Ants/ant5.svg"); }

        .arot0 { transform: rotate(0); }
        .arot1 { transform: rotate(90deg); }
        .arot2 { transform: rotate(180deg); }
        .arot3 { transform: rotate(270deg); }

        .netsquare .ant-child {
            position: absolute;
            width: 100%;
            height: 100%;
            background-position: center;
            background-repeat: no-repeat;
            background-size: contain;
            transition: width 0.2s, height 0.2s;
        }

        .netsquare .ant-child-0 {
            top: 0;
            left: 0;
        }

        .netsquare .ant-child-1 {
            top: 0;
            right: 0;
        }

        .netsquare .ant-child-2 {
            bottom: 0;
            left: 0;
        }

        .netsquare .ant-child-3 {
            bottom: 0;
            right: 0;
        }

        /* Reduce the size of the child squares when there are multiple ants */
        .netsquare.multiple .ant-child {
            width: 65%;
            height: 65%;
        }

        .tool.reset-grid {
            width: 60px;
            height: 60px;
            padding-top: 9px;
        }
        .square.nopointer {
            cursor: default;
            background: transparent;
            border: none;
        }
        .arrow-spacer {
            width: 35px;
        }
        .square-spacer {
            width: var(--sqsize);
            margin: 1px;
        }

        .gol-grid .square {
            width: 50px;
            height: 50px;
        }
        .gol-grid .square-row {
            height: 50px;
        }


        button {
            font-family: Special Elite;
            background-color: white;
            color: black;
            font-size: 18px;
            border-radius: 5px;
            border: black 3px solid;
            padding: 7px 10px;
            transition: color 1s, background-color 1s;
            margin: 2.5px;
        }
        button:hover {
            background-color: black;
            color: white;
        }
        button.flash {
            color: white;
            background-color: blue;
        }

        .button-spc { height: 29px; }
        .arrows button, .arrow-row button, .square-row button {
            height: 35px;
            width: 35px;
            font-size: 30px;
            padding: 0;
            line-height: 1.3;
            margin: 0;
        }
        button.btn-a {
            transform: rotateZ(90deg);
        }
        button.btn-d {
            transform: rotateZ(-90deg);
        }
        button.btn-w {
            transform: rotateZ(180deg);
        }
        .arrows button.btn-a {
            margin-right: -2.5%;
        }
        .arrows button.btn-d {
            margin-left: -2.5%;
        }

        body.play button.read-solve::before,
        button.read-solve.solve::before {
            content: 'Solve';
        }
        button.read-solve:not(.solve)::before {
            content: 'Read';
        }
        button.show-sol {
            padding: 3px 3px 1px 3px;
        }

        .solution {
            font-size: 15px;
            transition: 0.5s;
        }
        .solution span:not(.str) {
            display: inline-block;
            min-width: 108px;
        }
        body:not(.solution-shown) .solution,
        body:not(.play, .solve) .solution {
            color: transparent;
            font-size: 0;
        }
        .solution > div {
            font-family: 'Roboto Mono';
        }
        .solution > div div svg {
            width: 100px;
            transition: 0.5s;
        }
        body:not(.solution-shown) .solution div div svg,
        body:not(.play, .solve) .solution div div svg {
            width: 0;
        }

        .leave-button.leave {
            background-color: #F00;
        }

        body:not(.play, .solve) .arrows button,
        body:not(.play) button.show-sol,
        body:not(.play, .solve) .reset-grid,
        body:not(.play, .solve) .leave-button,
        :is(body:not(.play), body:not(.solution-shown)) .pause-button,
        body.solution-shown.play .reset-grid,
        body.play button.read-solve {
            user-select: none;
            pointer-events: none;
            background-color: #555;
        }
        button.expert-play.play::before {
            content: 'Generated';
        }
        button.expert-play:not(.play)::before {
            content: 'Manual';
        }
        button.sound.play::before {
            content: 'Sound';
        }
        button.sound:not(.play)::before {
            content: 'Muted';
        }
        button.show-sol.show::before {
            content: 'Solution Shown';
        }
        body:not(.play) button.show-sol::before,
        button.show-sol:not(.show)::before {
            content: 'Solution Hidden';
        }
        :is(body:not(.play), body:not(.solution-shown)) button.pause-button::before,
        button.pause-button.pause::before {
            content: 'Paused';
        }
        button.pause-button:not(.pause)::before {
            content: 'Playing';
        }

        .gol-grid {
            display: block;
            margin: 0 auto;
        }

        .page {
            background-repeat: repeat-y;
            background-position: top;
        }
    </style>
</head>
<body>
    <div class="section">
        <div class="page page-bg-02">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Game of Ants</span>
            </div>
            <div class="page-content">
                <img src="img/Component/Game of Ants.svg" class="diagram">
                <h2>On the Subject of Game of Ants</h2>
                <p class="flavour-text">The Circle rules your life.</p>
                <ul>
                    <li>On this module is a 5Ã—5 grid of cells that can be white or black. Within this grid, there are up to five red ants.</li>
                    <li>This is the initial state of a cellular automaton. To defuse the module, determine the state of the grid after the following steps have been performed.</li>
                </ul>
                <ol>
                    <li>Perform one iteration of <a target="_blank" href="Game of Life Simple.html">Game of Life</a> on the cells of the grid, ignoring the ants.</li>
                    <li>All ants simultaneously move one space forwards, toggling the state of cell it exited from.</li>
                    <li>If two or more ants end up on the same cell, apply these steps in order:
                        <ul>
                            <li>If the ants are facing in different directions, all move another space forwards.</li>
                            <li>If the ants are facing the same direction, all but one ant move another space forwards.</li>
                        </ul>
                    </li>
                    <li>If any ant leaves the grid, skip to step 6.</li>
                    <li>Each ant turns to its left if ends up on a black cell, or to its right if it ends up on a white cell. Repeat steps 2 to 5.</li>
                    <li>Perform another iteration of Game of Life on the resulting grid, once again ignoring the ants.</li>
                </ol>
                <p>To change the state of the grid, select a cell within it.</p>
                <ul>
                    <li>If the blinking button is active, selecting a cell toggles its state.</li>
                    <li>If the ant button is active:
                        <ul>
                            <li>Selecting an empty cell will place an ant on it in the orientation of the button.</li>
                            <li>Selecting a cell with an ant in a different orientation to the button changes the antâ€™s orientation to match.</li>
                            <li>Selecting a cell with an ant in the same orientation as the button removes the ant from the cell.</li>
                        </ul>
                    </li>
                    <li>Selecting either the blinking or ant button will activate that button and deactivate the other.
                        <ul>
                            <li>Selecting the ant button while it is active rotates it 90&deg; clockwise.</li>
                        </ul>
                    </li>
                    <li>Selecting an arrow marks a location where at least one ant left the grid.<br>Doing so will also activate the ant button and set its orientation to the direction of the arrow.</li>
                </ul>
                <h3>Interactive Controls</h3>
                <ul>
                    <li>
                        In <strong>Read</strong> mode:
                        <ul>
                            <li><strong>Click on a cell</strong> in the grid to toggle its color.</li>
                            <li>Press <strong>Space</strong>/<strong>Enter</strong>/<strong>0</strong> or <strong>1</strong> to quickly enter the Game of Life grid.</li>
                            <li><strong>Right-click on a cell</strong> in the Game of Life grid to mark it as changing.</li>
                            <li><strong>Click an ant tool</strong>, then click on a cell to place an ant in the selected orientation.</li>
                            <li>Using an <strong>ant tool</strong> will remove the ant of that type and replace it where you click.</li>
                            <li>Use the <strong>Rotate tool</strong> or <strong>Ctrl+Click</strong> an ant tool (or a cell containing an ant) to rotate 90Â° CW. <strong>Shift+Click</strong> to rotate CCW.</li>
                            <li>If a cell contains multiple ants, all ants in the cell will rotate.</li>
                        </ul>
                    </li>
                    <li>
                        In <strong>Solve</strong> mode:
                        <ul>
                            <li><strong>Select an occupied cell</strong> to toggle it and use the <strong>arrow keys</strong> or <strong>WASD</strong> to move the selected ant in the corresponding direction.</li>
                            <li>If a cell contains multiple ants, the first ant in reading order will be moved.</li>
                            <li><strong>Right-click</strong> a cell to select it without toggling.</li>
                            <li>The <strong>Reset</strong> button (â†») will restore the grid and ants to their initial state when switching into <strong>Solve</strong> mode.</li>
                            <li><strong>Click a bordering arrow button</strong> to mark locations where ants left the grid.</li>
                        </ul>
                    </li>
                    <li>
                        In <strong>Generated</strong> mode:
                        <ul>
                            <li>Press the <strong>Manual</strong> button to switch to <strong>Generated</strong> mode.</li>
                            <li>Have fun solving the generated puzzle!</li>
                            <li>Press the <strong>Solution Hidden</strong> button to show the step-by-step solution.</li>
                            <li>Press the <strong>Playing</strong> button to pause or resume the animation of the solution.</li>
                            <li>The puzzle is solved when all cells are the right color, all ants are in the right places and orientations (ant number doesnâ€™t matter), and the location where ant(s) left the grid are marked.</li>
                        </ul>
                    </li>
                    <li>The sound effects can be muted.</li>
                    <li>The <strong>Reset Saves</strong> button clears all the saved states.</li>
                    <li>The <strong>Reset All</strong> button resets the entire interactive.</li>
                </ul>
            </div>
            <div class="page-footer relative-footer">Page 1 of 2</div>
        </div>
        <div class="page page-bg-03 page2">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Game of Ants</span>
            </div>
            <div class="page-content">
                <div class="hstack top left">
                    <div class="vstack">
                        <p><strong>Game of Life</strong></p>
                        <button class="clear-dots">Clear Dots</button>
                    </div>
                    <div class="grid gol-grid vstack left"></div>
                </div>
                <div class="hstack wrap">
                    <div class="vstack tools alignc">
                        <p class="gridlabel"><strong>Ant Grid</strong></p>
                        <h3 class="solved-text invis centered">Solved!</h3>
                        <div class="hstack arrows alignc">
                            <button class="btn-a">â–¼</button>
                            <div class="vstack alignc">
                                <button class="btn-w">â–¼</button>
                                <div class="button-spc"></div>
                                <button class="btn-s">â–¼</button>
                            </div>
                            <button class="btn-d">â–¼</button>
                        </div>
                        <div class="tool reset-grid">â†»</div>
                    </div>
                    <div class="grid ant-grid vstack left"></div>
                </div>
                <div style="height: 5mm"></div>
                <div class="saves hstack wrap left">
                    <button class="save">Save</button>
                </div>
                <div class="hstack left" style="margin-top: 5mm">
                    <button class="reset-saves">Reset Saves</button>
                    <button class="reset-all">Reset All</button>
                    <div style="width: 8mm"></div>
                </div>
                <div style="height: 5mm"></div>
                <div class="solution hstack left top wrap gap2">
                    <div class="vstack alignc">
                        <span>Life phase yields</span>
                        <div class="life-phase"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Ant travel</span>
                        <div class="ant-travel"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Ant phase yields</span>
                        <div class="ant-phase"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Final state</span>
                        <div class="final-state"></div>
                    </div>
                </div>
            </div>
            <div class="page-footer relative-footer">Page 2 of 2</div>
        </div>
    </div>
</body>
</html>